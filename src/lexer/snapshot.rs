use super::{instant::Instant, Lexer};

/// The snapshot of the stateful [`Lexer`].
///
/// This can be created by [`Lexer::snapshot`]
/// and use by [`Lexer::restore`] and [`Lexer::clone_with_snapshot`].
///
/// You can't construct this manually because
/// you shouldn't modify [`Self::instant`] directly.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Snapshot<'text, State> {
  /// See [`Lexer::state`].
  pub state: State,
  /// See [`Self::instant`].
  pub(super) instant: Instant<'text>,
}

impl<'text, State> Snapshot<'text, State> {
  /// Get the [`Lexer::instant`] in the [`Snapshot`].
  /// You can't modify this manually.
  #[inline]
  pub const fn instant(&self) -> &Instant<'text> {
    &self.instant
  }
}

/// Partial [`Snapshot`].
///
/// This is usually generated by a lex
/// with [`LexOptions::fork`](crate::lexer::options::LexOptions::fork) enabled,
/// in which case, the [`Self::state`] will be [`Some`] if the [`Lexer::state`]
/// is mutated during the lex, and the [`Self::instant`] will be [`Some`] if the
/// lex digest more than 0 bytes.
///
/// This can be turned into a full [`Snapshot`] by [`Self::into_full`].
///
/// You can't construct this manually because
/// you shouldn't modify [`Self::instant`] directly.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct PartialSnapshot<'text, State> {
  /// See [`Lexer::state`].
  pub state: Option<State>,
  /// See [`Self::instant`].
  pub(super) instant: Option<Instant<'text>>,
}

impl<'text, State> From<Snapshot<'text, State>> for PartialSnapshot<'text, State> {
  #[inline]
  fn from(snapshot: Snapshot<'text, State>) -> Self {
    PartialSnapshot {
      state: Some(snapshot.state),
      instant: Some(snapshot.instant),
    }
  }
}

impl<'text, State> PartialSnapshot<'text, State> {
  /// Get the [`Lexer::instant`] in the [`PartialSnapshot`].
  /// You can't modify this manually.
  #[inline]
  pub const fn instant(&self) -> &Option<Instant<'text>> {
    &self.instant
  }

  /// Consume self, build a full [`Snapshot`].
  /// This will clone [`Lexer::state`] and/or [`Lexer::instant`]
  /// if [`Self::state`] and/or [`Self::instant`] are [`None`].
  #[inline]
  pub fn into_full<Kind, ErrorType>(
    self,
    lexer: &Lexer<'text, Kind, State, ErrorType>,
  ) -> Snapshot<'text, State>
  where
    State: Clone,
  {
    Snapshot {
      state: self.state.unwrap_or_else(|| lexer.state.clone()),
      instant: self.instant.unwrap_or_else(|| lexer.instant().clone()),
    }
  }
}

#[cfg(test)]
mod tests {
  use crate::lexer::{token::MockTokenKind, LexerBuilder};

  use super::*;

  #[test]
  fn test_snapshot() {
    assert_eq!(
      Snapshot {
        state: (),
        instant: Instant::new("")
      }
      .instant(),
      &Instant::new("")
    );
  }

  #[test]
  fn test_partial_snapshot() {
    let partial: PartialSnapshot<()> = PartialSnapshot {
      state: None,
      instant: None,
    };
    assert_eq!(partial.instant(), &None);

    let snapshot = partial.into_full(&LexerBuilder::<MockTokenKind<()>>::new().build("123"));
    assert_eq!(snapshot.state, ());
    assert_eq!(snapshot.instant(), &Instant::new("123"));
  }
}
