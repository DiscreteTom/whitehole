//! ## Design
//!
//! For a better engineering experience, the lexer is designed to be modular
//! and consists of many [`Action`]s. Each action is a small piece of logic
//! which will digest some bytes from the rest of the text input, and optionally yield a token.
//! By doing so, users can easily compose their own lexer by re-using existing actions.
//! Users can also share their actions with others by publishing them as a library,
//! or build higher-level libraries to generate actions.
//!
//! ## For Developers
//!
//! Here is the recommended order of reading the source code:
//!
//! - [`self::input`]
//! - [`self::output`]
//! - [`self`]
//! - [`self::decorator`]
//! - [`self::simple`]
//! - [`self::utils`]

mod decorator;
mod input;
mod output;
mod simple;
mod utils;

pub use decorator::*;
pub use input::*;
pub use output::*;
pub use simple::*;
pub use utils::*;

use super::token::TokenKindId;
use std::collections::HashSet;

/// See [`Action::head`].
#[derive(PartialEq, Debug, Clone)]
pub enum HeadMatcher {
  OneOf(HashSet<char>),
  Not(HashSet<char>),
  /// Match any characters that are not known in
  /// [`OneOf`](HeadMatcher::OneOf) or [`Not`](HeadMatcher::Not).
  Unknown,
}

// TODO: move to a single mod
pub enum ActionExec<Kind, ActionState, ErrorType> {
  Immutable(
    Box<dyn Fn(&ActionInput<&ActionState>) -> Option<ActionOutput<Kind, Option<ErrorType>>>>,
  ),
  Mutable(
    Box<
      dyn Fn(&mut ActionInput<&mut ActionState>) -> Option<ActionOutput<Kind, Option<ErrorType>>>,
    >,
  ),
}

/// To create this, use [`simple`](simple::simple), [`simple_with_data`](simple::simple_with_data)
/// or [`utils`] (like [`regex`](utils::regex), [`exact`], [`word`]).
pub struct Action<Kind: 'static, ActionState = (), ErrorType = ()> {
  // input is mutable so the action can mutate the action state.
  exec: ActionExec<Kind, ActionState, ErrorType>,
  /// See [`Self::kind`].
  kind: &'static TokenKindId<Kind>,
  /// See [`Self::literal`].
  literal: Option<String>,
  /// See [`Self::head`].
  head: Option<HeadMatcher>,
  /// See [`Self::muted`].
  muted: bool,
}

impl<Kind, ActionState, ErrorType> Action<Kind, ActionState, ErrorType> {
  /// This is used to accelerate expectational lexing if an expected kind is provided,
  /// see [`Expectation::kind`](crate::lexer::expectation::Expectation::kind).
  /// Every action must have this field set by [`Self::bind`],
  /// [`Self::bind_default`] or [`Self::select`].
  // these method will ensure the integrity between the `Self::kind` and the `ActionOutput::kind`
  #[inline]
  pub const fn kind(&self) -> &'static TokenKindId<Kind> {
    &self.kind
  }

  /// This is used to accelerate expectational lexing if an expected literal is provided,
  /// see [`Expectation::literal`](crate::lexer::expectation::Expectation::literal).
  /// If set, tokens' text content generated by this action must equals to this value
  /// (but this won't be checked during the runtime).
  /// This field is optional and can only be set via [`exact`] and [`word`].
  #[inline]
  pub const fn literal(&self) -> &Option<String> {
    &self.literal
  }

  /// This is used to accelerate lexing by the first character
  /// of the rest of the input. This is optional but highly recommended.
  /// Some [`utils`] already set this field safely (e.g. [`exact`] and [`word`]) and you should use them as much as possible.
  /// If you want to set this field manually,
  /// this could be set by [`Self::unchecked_head_in`], [`Self::unchecked_head_in_range`],
  /// [`Self::unchecked_head_not`] or [`Self::unchecked_head_unknown`].
  #[inline]
  pub const fn head(&self) -> &Option<HeadMatcher> {
    &self.head
  }

  /// Muted actions won't yield tokens and won't stop a lexing process from running.
  /// This field could be set via [`Self::mute`] or [`Self::unmute`].
  #[inline]
  pub const fn muted(&self) -> bool {
    self.muted
  }

  /// Execute the action.
  #[inline]
  pub fn exec(&self) -> &ActionExec<Kind, ActionState, ErrorType> {
    &self.exec
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use crate::lexer::token::SubTokenKind;
  use whitehole_macros::_token_kind;

  #[_token_kind]
  #[derive(Debug)]
  enum MyKind {
    A,
  }

  #[test]
  fn action_getters_default() {
    let action: Action<_> = Action {
      exec: Box::new(|_| None),
      kind: A::kind_id(),
      head: None,
      muted: false,
      may_mutate_state: false,
      literal: None,
    };
    assert!(!action.muted());
    assert!(!action.may_mutate_state());
    assert!(action.never_mutate_state());
    assert_eq!(action.kind(), A::kind_id());
    assert!(action.head().is_none());
    assert!(action.literal().is_none());
  }

  #[test]
  fn action_getters() {
    let action: Action<_> = Action {
      exec: Box::new(|_| None),
      kind: A::kind_id(),
      head: Some(HeadMatcher::OneOf(HashSet::from(['a']))),
      muted: true,
      may_mutate_state: true,
      literal: Some("123".into()),
    };
    assert!(action.muted());
    assert!(action.may_mutate_state());
    assert!(!action.never_mutate_state());
    assert_eq!(action.kind(), A::kind_id());
    assert!(matches!(action.head(), Some(HeadMatcher::OneOf(set)) if set == &HashSet::from(['a'])));
    assert_eq!(action.literal(), &Some("123".into()));
  }
}
