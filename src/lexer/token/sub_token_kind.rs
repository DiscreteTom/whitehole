use super::TokenKindId;

/// Usually we use enum to represent a "token kind".
/// Each variant of the enum is a sub token kind.
/// Every sub token kind should have a unique kind id.
/// Usually we create a struct for each variant and implement this
/// trait for those structs so each of them have a unique id.
/// This can be auto implemented by applying [`token_kind`](crate::lexer::token::token_kind)
/// to the token kind enum.
/// # Examples
/// ```
/// use whitehole::lexer::token::{TokenKindId, token_kind, SubTokenKind};
///
/// #[token_kind]
/// #[derive(Debug)]
/// enum MyKind { A, B }
/// // struct `A` and `B` are generated by the macro
/// // and implement `SubTokenKind<TokenKindIdBinding<MyKind>>`
///
/// # fn main() {
/// assert_eq!(A::kind_id(), &TokenKindId::new(0));
/// assert_eq!(B::kind_id(), &TokenKindId::new(1));
/// # }
/// ```
pub trait SubTokenKind<TokenKindType> {
  /// Return the kind id of this sub token kind.
  fn kind_id() -> &'static TokenKindId<TokenKindType>;
}
