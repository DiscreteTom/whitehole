use std::{
  hash::{Hash, Hasher},
  marker::PhantomData,
};

/// The unique id of a sub token kind.
/// You can consider [`TokenKindId`] just like [`std::mem::Discriminant`],
/// but the internal implementation shouldn't be relied upon by your application.
/// The id and the value can be bound together by [`TokenKindIdBinding`](super::TokenKindIdBinding).
/// The bindings can be auto generated by applying [`token_kind`](crate::lexer::token::token_kind)
/// to the token kind enum.
/// # Examples
/// ```
/// use whitehole::lexer::token::{token_kind, TokenKindIdBinding, TokenKindIdProvider};
///
/// #[token_kind]
/// #[derive(Debug)]
/// enum MyKind { A, B(i32) }
/// // struct `A` and `B` are generated by the macro
/// // and implement `Into<TokenKindIdBinding<MyKind>>`
///
/// # fn main() {
/// let a: TokenKindIdBinding<MyKind> = A.into();
/// let b1: TokenKindIdBinding<MyKind> = B(1).into();
/// let b2: TokenKindIdBinding<MyKind> = B(2).into();
/// assert_eq!(a.id(), a.id());
/// assert_eq!(b1.id(), b2.id());
/// assert_ne!(a.id(), b1.id());
/// # }
/// ```
/// # Design
/// ## Why not just use [`std::mem::Discriminant`]?
/// `Discriminant` is good, it can be used to get the unique id of an enum variant value,
/// so with `Discriminant` we don't need [`TokenKindIdBinding`](super::TokenKindIdBinding) anymore.
/// However `Discriminant` requires an instance of the enum to construct it,
/// so when using [`Action::select`](crate::lexer::action::Action::select),
/// or in the implementations of [`SubTokenKind`](super::SubTokenKind),
/// or in expectational lexing,
/// we need to construct the variant value first, just to get the id,
/// which is neither necessary nor convenient.
/// ## Why not just use [`std::any::TypeId`]?
/// - We hope the id is type-sensitive (that's why there is a [`PhantomData`] in the struct),
/// `TypeId` is not.
/// - Currently `TypeId` use 128 bits to represent the type, which is too large for our purpose.
#[derive(Debug)]
pub struct TokenKindId<Kind> {
  value: usize,
  name: &'static str,
  __: PhantomData<Kind>,
}

impl<Kind> TokenKindId<Kind> {
  /// You should NEVER call this function directly.
  /// This function should only be used in the [`token_kind`](super::token_kind) macro.
  #[inline]
  pub const fn new(value: usize, name: &'static str) -> Self {
    Self {
      value,
      name,
      __: PhantomData,
    }
  }

  /// The name of the sub token kind.
  ///
  /// This is only used for display when debugging.
  /// The value won't be used in logic (e.g. [`PartialEq`], [`Hash`]).
  #[inline]
  pub const fn name(&self) -> &'static str {
    self.name
  }
}

// manually implement these traits to avoid `Kind`
// being `Clone`, `Copy`, `Eq`, `PartialEq`, `Hash
impl<Kind> Clone for TokenKindId<Kind> {
  #[inline]
  fn clone(&self) -> Self {
    Self::new(self.value, self.name)
  }
}
impl<Kind> Copy for TokenKindId<Kind> {}
impl<Kind> PartialEq for TokenKindId<Kind> {
  #[inline]
  fn eq(&self, other: &Self) -> bool {
    // we only need to compare the value
    self.value == other.value
  }
}
impl<Kind> Eq for TokenKindId<Kind> {}
impl<Kind> Hash for TokenKindId<Kind> {
  #[inline]
  fn hash<H: Hasher>(&self, state: &mut H) {
    // we only need to hash the value
    self.value.hash(state);
  }
}

/// Calling [`TokenKindIdProvider::id`] to get the [`TokenKindId`] of a token kind value.
/// Usually we use [`TokenKindIdBinding`](super::TokenKindIdBinding) to bind the id and the value together,
/// which already implement this trait.
/// The bindings can be auto generated by applying [`token_kind`](super::token_kind)
/// to the token kind enum.
/// # Examples
/// ```
/// use whitehole::lexer::token::{token_kind, TokenKindIdBinding, TokenKindIdProvider};
///
/// #[token_kind]
/// #[derive(Debug)]
/// enum MyKind { A, B(i32) }
/// // struct `A` and `B` are generated by the macro
/// // and implement `Into<TokenKindIdBinding<MyKind>>`
///
/// # fn main() {
/// let a: TokenKindIdBinding<MyKind> = A.into();
/// assert_eq!(a.id(), a.id());
/// # }
/// ```
pub trait TokenKindIdProvider {
  type TokenKind;
  /// The token kind id of this token kind value.
  /// See [`TokenKindId`].
  fn id(&self) -> &'static TokenKindId<Self::TokenKind>; // use a static reference to avoid creating a new one every time
}

#[cfg(test)]
mod tests {
  use crate::lexer::token::SubTokenKind;

  use super::*;
  use std::collections::HashSet;
  use whitehole_macros::_token_kind;

  #[_token_kind]
  #[derive(Debug)]
  enum MyKind {
    A,
  }

  #[test]
  fn token_kind_id_new() {
    let id = TokenKindId::new(42, "Sub") as TokenKindId<MyKind>;
    assert_eq!(id.value, 42);
    assert_eq!(id.name, "Sub");
    assert_eq!(id.name(), "Sub");
  }

  #[test]
  fn token_kind_id_clone() {
    // ensure we don't need to impl Clone for MyKind but the clone is still working
    let id = TokenKindId::new(42, "Sub") as TokenKindId<MyKind>;
    let id_clone = id.clone();
    assert_eq!(id.value, id_clone.value);
    assert_eq!(id.name, id_clone.name);
  }

  #[test]
  fn token_kind_id_copy() {
    // ensure we don't need to impl Copy for MyKind but the copy is still working
    let id = TokenKindId::new(42, "Sub") as TokenKindId<MyKind>;
    let id_copy = id;
    assert_eq!(id.value, id_copy.value);
    assert_eq!(id.name, id_copy.name);
  }

  #[test]
  fn token_kind_id_eq() {
    // ensure we don't need to impl PartialEq for MyKind but the eq is still working
    // ensure we don't compare the name
    let id1 = TokenKindId::new(42, "") as TokenKindId<MyKind>;
    let id2 = TokenKindId::new(42, "Sub") as TokenKindId<MyKind>;
    assert_eq!(id1, id2);
  }

  #[test]
  fn token_kind_id_hash() {
    // ensure we don't need to impl Hash for MyKind but the hash is still working
    // ensure we don't hash the name
    let id1 = TokenKindId::new(42, "") as TokenKindId<MyKind>;
    let id2 = TokenKindId::new(42, "Sub") as TokenKindId<MyKind>;
    let set = HashSet::from([id1]);
    assert!(set.contains(&id1));
    assert!(set.contains(&id2));
  }

  #[test]
  fn token_kind_id_debug() {
    // ensure the string representation contains the sub token kind name
    assert_eq!(
      format!("{:?}", A::kind_id()),
      "TokenKindId { value: 0, name: \"A\", __: PhantomData<whitehole::lexer::token::binding::TokenKindIdBinding<whitehole::lexer::token::token_kind_id::tests::MyKind>> }"
    );
  }
}
