use std::{fmt::Debug, hash::Hash, marker::PhantomData};

/// The unique id of a sub token kind.
/// Usually we use enum variants as sub token kinds, and the id is the variant's index,
/// The id and the value can be bound together by [`TokenKindIdBinding`](super::TokenKindIdBinding).
/// The bindings can be auto generated by applying [`token_kind`](crate::lexer::token::token_kind)
/// to the token kind enum.
/// # Examples
/// ```
/// use whitehole::lexer::token::{token_kind, TokenKindId, TokenKindIdBinding};
///
/// #[token_kind]
/// enum MyKind { A, B }
/// // struct `A` and `B` are generated by the macro
/// // and implement `Into<TokenKindIdBinding<MyKind>>`
///
/// let a: TokenKindIdBinding<MyKind> = A.into();
/// let b: TokenKindIdBinding<MyKind> = B.into();
/// assert_eq!(a.id(), &TokenKindId::new(0));
/// assert_eq!(b.id(), &TokenKindId::new(1));
/// ```
// `TokenKindType` should impl `Debug`
#[derive(Debug)]
// the `usize`/`self.0` is not public because we don't need to expose the value.
// if user want to inspect the value they can use `Debug` instead
// or they can check the inner value by `==`
pub struct TokenKindId<TokenKindType>(usize, PhantomData<TokenKindType>);

impl<TokenKindType> TokenKindId<TokenKindType> {
  pub const fn new(id: usize) -> Self {
    TokenKindId(id, PhantomData)
  }
}

impl<TokenKindType> Copy for TokenKindId<TokenKindType> {}
impl<TokenKindType> Clone for TokenKindId<TokenKindType> {
  fn clone(&self) -> Self {
    TokenKindId(self.0, PhantomData)
  }
}

impl<TokenKindType> Eq for TokenKindId<TokenKindType> {}
impl<TokenKindType> PartialEq for TokenKindId<TokenKindType> {
  fn eq(&self, other: &Self) -> bool {
    self.0 == other.0
  }
}

impl<TokenKindType> Hash for TokenKindId<TokenKindType> {
  fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
    self.0.hash(state);
  }
}

/// Calling [`TokenKindIdProvider::id`] to get the [`TokenKindId`] of a token kind value.
/// Usually we use [`TokenKindIdBinding`](super::TokenKindIdBinding) to bind the id and the value together,
/// which already implement this trait.
/// The bindings can be auto generated by applying [`token_kind`](super::token_kind)
/// to the token kind enum.
/// # Examples
/// ```
/// use whitehole::lexer::token::{token_kind, TokenKindId, TokenKindIdBinding};
///
/// #[token_kind]
/// enum MyKind { A, B }
/// // struct `A` and `B` are generated by the macro
/// // and implement `Into<TokenKindIdBinding<MyKind>>`
///
/// let a: TokenKindIdBinding<MyKind> = A.into();
/// let b: TokenKindIdBinding<MyKind> = B.into();
/// assert_eq!(a.id(), &TokenKindId::new(0));
/// assert_eq!(b.id(), &TokenKindId::new(1));
/// ```
pub trait TokenKindIdProvider<TokenKindType> {
  /// The token kind id of this token kind value.
  /// See [`TokenKindId`].
  fn id(&self) -> &'static TokenKindId<TokenKindType>;
}

#[cfg(test)]
mod tests {
  use super::*;
  use std::collections::HashSet;
  use whitehole_macros::_token_kind;

  #[_token_kind]
  #[derive(Debug)]
  enum MyKind {
    A,
  }

  #[test]
  fn token_kind_id_new() {
    let id = TokenKindId::new(42) as TokenKindId<MyKind>;
    assert_eq!(id.0, 42);
  }

  #[test]
  fn token_kind_id_clone() {
    // ensure we don't need to impl Clone for MyKind but the clone is still working
    let id = TokenKindId::new(42) as TokenKindId<MyKind>;
    let id_clone = id.clone();
    assert_eq!(id, id_clone);
  }

  #[test]
  fn token_kind_id_eq() {
    // ensure we don't need to impl PartialEq for MyKind but the eq is still working
    let id1 = TokenKindId::new(42) as TokenKindId<MyKind>;
    let id2 = TokenKindId::new(42) as TokenKindId<MyKind>;
    assert_eq!(id1, id2);
  }

  #[test]
  fn token_kind_id_hash() {
    // ensure we don't need to impl Hash for MyKind but the hash is still working
    let id = TokenKindId::new(42) as TokenKindId<MyKind>;
    let set = HashSet::from([id]);
    assert!(set.contains(&id));
  }
}
