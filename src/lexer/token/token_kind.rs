use super::TokenKindId;

/// Usually we use enum to represent a token kind family.
/// Each variant of the enum is a sub token kind.
/// Every sub token kind should have a unique kind id.
/// Usually we create a struct for each variant and implement this for those structs.
/// This can be auto generated by deriving [`whitehole_macros::TokenKind`] for the enum.
/// # Examples
/// ```
/// use std::collections::HashSet;
/// use whitehole_macros::TokenKind;
/// use whitehole::lexer::token::{TokenKindId, TokenKind};
///
/// #[derive(TokenKind)]
/// enum MyKind { A, B }
/// // struct `A` and `B` are generated by the macro
/// // and implement `SubTokenKind<TokenKindIdBinding<MyKind>>`
///
/// assert_eq!(A::kind_id(), TokenKindId::new(0));
/// assert_eq!(B::kind_id(), TokenKindId::new(1));
/// ```
pub trait SubTokenKind<TokenKindType> {
  /// Return the kind id of this sub token kind.
  fn kind_id() -> TokenKindId<TokenKindType>;
}
