use super::{DefaultTokenKind, SubTokenKind, TokenKindId};

/// Bind the token kind value with an [`TokenKindId`].
///
/// This is readonly to make sure the binding is not broken,
/// you can use [`Self::take`] to take the kind value out.
/// # Examples
/// ```
/// use whitehole::lexer::token::{token_kind, TokenKindIdBinding, SubTokenKind};
///
/// #[token_kind]
/// #[derive(Debug)]
/// enum MyKind { A, B(i32) }
/// // struct `A` and `B` will be generated by the macro
///
/// # fn main() {
/// let a: TokenKindIdBinding<MyKind> = A.into();
/// let b: TokenKindIdBinding<MyKind> = B(0).into();
/// assert_eq!(a.id(), A::kind_id());
/// assert_eq!(b.id(), B::kind_id());
/// assert!(matches!(a.kind(), MyKind::A));
/// assert!(matches!(b.kind(), MyKind::B(B(0))));
/// # }
/// ```
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TokenKindIdBinding<Kind> {
  id: TokenKindId<Kind>,
  kind: Kind,
}

// this is the only way to construct self
impl<Kind, ViaKind: SubTokenKind<TokenKind = Kind> + Into<Kind>> From<ViaKind>
  for TokenKindIdBinding<Kind>
{
  #[inline]
  fn from(value: ViaKind) -> Self {
    Self {
      id: ViaKind::kind_id(),
      kind: value.into(),
    }
  }
}

impl<Kind> TokenKindIdBinding<Kind> {
  /// Get the id of the sub token kind.
  /// See [`TokenKindId`].
  #[inline]
  pub const fn id(&self) -> TokenKindId<Kind> {
    self.id
  }

  /// Get the value of the token kind.
  #[inline]
  pub const fn kind(&self) -> &Kind {
    &self.kind
  }

  /// Consume self and take the kind value out.
  #[inline]
  pub fn take(self) -> Kind {
    self.kind
  }
}

impl<Kind: DefaultTokenKind + Default> Default for TokenKindIdBinding<Kind> {
  #[inline]
  fn default() -> Self {
    Self {
      id: Kind::default_kind_id(),
      kind: Kind::default(),
    }
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use whitehole_macros::_token_kind;

  #[_token_kind]
  #[derive(Debug, PartialEq, Default)]
  enum MyKind {
    #[default]
    A,
  }

  #[test]
  fn token_kind_id_binding() {
    let binding: TokenKindIdBinding<_> = A.into();
    assert_eq!(binding.id(), A::kind_id());
    assert_eq!(binding.kind(), &MyKind::A);
    assert_eq!(binding.take(), MyKind::A);
  }

  #[test]
  fn default_token_kind_id_binding() {
    let binding = TokenKindIdBinding::<MyKind>::default();
    assert_eq!(binding.id(), MyKind::default_kind_id());
    assert_eq!(binding.take(), MyKind::default());
  }
}
