use std::{
  any::type_name,
  fmt::{self, Debug},
  hash::{Hash, Hasher},
  marker::PhantomData,
};

/// The unique id of a sub kind.
/// The [`Self::value`] is the index of the enum variant.
/// The sub kind id and the kind value can be bound together
/// by [`KindIdBinding`](super::KindIdBinding).
/// The bindings can be auto generated by applying [`whitehole_kind`](crate::kind::whitehole_kind) macro
/// to the kind enum.
/// # Examples
/// ```
/// use whitehole::kind::{whitehole_kind, KindIdBinding};
///
/// #[whitehole_kind]
/// #[derive(Debug)]
/// enum MyKind { A, B(i32) }
/// // struct `A` and `B` are generated by the macro
/// // and implement `Into<KindIdBinding<MyKind>>`
///
/// # fn main() {
/// let a: KindIdBinding<MyKind> = A.into();
/// let b1: KindIdBinding<MyKind> = B(1).into();
/// let b2: KindIdBinding<MyKind> = B(2).into();
/// assert_eq!(a.id(), a.id());
/// assert_eq!(b1.id(), b2.id());
/// assert_ne!(a.id(), b1.id());
/// # }
/// ```
/// # Design
/// ## Why not just use [`std::mem::Discriminant`]?
/// `Discriminant` is good, it can be used to get the unique id of an enum variant value,
/// so with `Discriminant` we don't need [`KindIdBinding`](super::KindIdBinding) anymore.
/// However `Discriminant` requires an instance of the enum to construct it,
/// so when using [`Action::select`](crate::lexer::action::Action::select),
/// or in the implementations of [`SubKind`](super::SubKind),
/// or in expectational lexing,
/// we need to construct the variant value first, just to get the id,
/// which is neither necessary nor convenient.
/// ## Why not just use [`std::any::TypeId`]?
/// - We hope the id is type-sensitive (that's why there is a [`PhantomData`] in the struct), `TypeId` is not.
/// - Currently `TypeId` use 128 bits to represent the type, which is too large for our purpose.
/// ## Others
/// By using [`usize`] as the id, we can use this as the index of a lookup table.
/// And it is small enough to be passed around by value.
pub struct SubKindId<Kind> {
  value: usize,
  __: PhantomData<Kind>,
}

impl<Kind> SubKindId<Kind> {
  /// This is internal to prevent users from creating the id directly.
  /// All the ids should be created by [`SubKind::kind_id`](super::SubKind::kind_id).
  #[inline]
  pub(super) const fn new(value: usize) -> Self {
    Self {
      value,
      __: PhantomData,
    }
  }

  /// The index of the enum variant.
  #[inline]
  pub const fn value(&self) -> usize {
    self.value
  }
}

// manually implement these traits to avoid `Kind`
// being `Debug`, `Copy`, `Clone`, `Eq`, `PartialEq`, `Hash`
impl<Kind> Debug for SubKindId<Kind> {
  #[inline]
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    f.debug_tuple(&format!("SubKindId<{}>", type_name::<Kind>()))
      .field(&self.value)
      .finish()
  }
}
impl<Kind> Copy for SubKindId<Kind> {}
impl<Kind> Clone for SubKindId<Kind> {
  #[inline]
  fn clone(&self) -> Self {
    *self
  }
}
impl<Kind> PartialEq for SubKindId<Kind> {
  #[inline]
  fn eq(&self, other: &Self) -> bool {
    self.value == other.value
  }
}
impl<Kind> Eq for SubKindId<Kind> {}
impl<Kind> Hash for SubKindId<Kind> {
  #[inline]
  fn hash<H: Hasher>(&self, state: &mut H) {
    self.value.hash(state);
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use crate::kind::{DefaultSubKind, SubKind};
  use std::collections::HashSet;
  use whitehole_macros::_whitehole_kind;

  #[_whitehole_kind]
  #[derive(Debug, Default)]
  enum MyKind {
    A,
    #[default]
    B,
  }

  #[test]
  fn token_kind_id_new_and_value() {
    let id = SubKindId::new(42) as SubKindId<MyKind>;
    assert_eq!(id.value(), 42);
  }

  #[test]
  fn token_kind_id_copy() {
    // ensure we don't need to impl Clone/Copy for MyKind but the copy is still working
    let id = SubKindId::new(42) as SubKindId<MyKind>;
    let id_copy = id;
    assert_eq!(id.value, id_copy.value);
  }

  #[test]
  fn token_kind_id_eq() {
    // ensure we don't need to impl PartialEq for MyKind but the eq is still working
    let id1 = SubKindId::new(42) as SubKindId<MyKind>;
    let id2 = SubKindId::new(42) as SubKindId<MyKind>;
    assert_eq!(id1, id2);
  }

  #[test]
  fn token_kind_id_hash() {
    // ensure we don't need to impl Hash for MyKind but the hash is still working
    let id1 = SubKindId::new(42) as SubKindId<MyKind>;
    let id2 = SubKindId::new(42) as SubKindId<MyKind>;
    let set = HashSet::from([id1]);
    assert!(set.contains(&id1));
    assert!(set.contains(&id2));
  }

  #[test]
  fn token_kind_id_debug() {
    assert_eq!(
      format!("{:?}", A::kind_id()),
      "SubKindId<whitehole::kind::id::tests::MyKind>(0)"
    );
  }

  #[test]
  fn default_token_kind_id() {
    // default token kind id is not always 0
    assert_eq!(MyKind::default_kind_id(), B::kind_id());
  }
}
